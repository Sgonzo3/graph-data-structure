<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Data Structure Notes</title>
</head>
<body>
    <script>

        
        /*
        Trees = Graphs with specific shape of connections

        Graphs can contain cyclces and have no specific head

        Undirected vs Directed Graphs
             - control traversal in one direction for directed graphs
             - undirected graphs ie facebook networks, the relationship is mutual
             - directed graphs ie twitter, instagram followers, relationships are distinct between nodes. Can follow without being foloowed back.
        
        Weighted Graphs
            - 

        Adjacency Matrix
            - a table where each node has its own ro and column and defaults to zero except wjere connections are present
            - for every directed edge add 1 to the cell at the row of origin an and the column of of the destination. If Undirected treat it as biderectional
        Adjacency List
             - object or hash table where every node has its own key and each corresponding value is an array of all destiination nodes from that origin node
        */
        
        class Graph {
            constructor() {
                // this.adjacencyList = {}
                this.adjacencyList = new Set();
            }

            addVertex(vertex){
                if(vertex) {
                    this.adjacencyList[vertex] = [];
                    this.adjacencyList[vertex] = new Set();
                }
            }

            addEdge(vertex1, vertex2){
                // should check for valid keys in vertex1 and vertex2
                if(!this.adjacencyList[vertex1]) this.addVertex(vertex1);
                if(!this.adjacencyList[vertex2]) this.addVertex(vertex2);
                this.adjacencyList[vertex1].add(vertex2);
                this.adjacencyList[vertex2].add(vertex1);
            }
            print(){

            }

            removeEdge(vertex1, vertex2) {
                if(!this.adjacencyList[vertex1] || !this.adjacencyList[vertex2]) {
                    return "invalid vertexes to delete";
                }
                // this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(item => item !== vertex2);
                this.adjacencyList[vertex1].delete(vertex2)

                // this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(item => item !== vertex1);
                this.adjacencyList[vertex2].delete(vertex1)

                return this.adjacencyList;
            }

            removeVertex(vertex){
                this.adjacencyList[vertex].forEach(item => this.removeEdge(item, vertex));
                delete this.adjacencyList[vertex];
                return this.adjacencyList;
            }

            depthFirstSearchInterative(startVertex){
                let stack = [startVertex];
                let visited = {}; // can this be a set?
                let result = [];
                while(stack){
                    const current = stack.pop();
                    if(visited[current]) return;
                }
                for(let each in this.adjacencyList){

                }
            }

            breadthFirstSearch(){

            }
        }

        myGraph = new Graph();
        console.log(myGraph.adjacencyList);
        myGraph.addEdge("A", "B");
        console.log(myGraph.adjacencyList);
        myGraph.addEdge("D", "C");
        console.log(myGraph.adjacencyList);
        myGraph.addEdge("A", "Z");
        console.log(myGraph.adjacencyList);
        myGraph.addEdge("A", "Z");
        console.log(myGraph.adjacencyList);
        console.log(myGraph.removeEdge("X", "Y"));
        console.log(myGraph.removeEdge("A", "B"));
        console.log(myGraph.removeVertex("A"));
    </script>
</body>
</html>